MySQL 인덱스 & 쿼리 튜닝 실험 (데이터 분포별 성능 비교)

대용량 주문/회원 데이터에서 인덱스 유무, 데이터 분포(기간 선택도), 쿼리 작성 방식이 성능에 미치는 영향을 실험한 쿼리 모음입니다.
모든 쿼리는 원문 그대로 보존했으며, 재현에 필요한 최소한의 안내만 제공합니다.



orders_2024_2025: 2024-01-01 ~ 2025-09-03 분포 (선택도 높음)

orders_2019_2025: 2019-01-01 ~ 2025-09-03 분포 (선택도 낮음)

요구 사항

MySQL 8.0.18+ ( EXPLAIN ANALYZE 지원 버전 )

적절한 워크로드 크기 (예: orders 10M, members 100K)

쿼리 파일 상단의 USE <database>; 등은 환경에 맞게 조정해 주세요.

실행 방법


실험 요약 (1–8)
#	데이터셋(기간 선택도)	접근 방식/전략	실행 시간*	결과 건수
1	2024~2025 (높음)	member_no_pk 인덱스 없음, 드라이빙 전환	1,370,000 ms (~22m50s)	—
2	2024~2025 (높음)	Full Scan + PK Lookup	15,177 ms	99,985
3	2024~2025 (높음)	Covering Index Range Scan (order_date, member_id)	4,348 ms	99,985
4	2019~2025 (낮음)	Full Scan + PK Lookup	8,828 ms	71,688
5	2019~2025 (낮음)	Covering Index Range Scan	592 ms	71,688
6	2019~2025 (낮음)	IN/EXISTS(세미조인 유사)	~200 ms	71,688
7	20192025 (낮음) / 20242025 (높음)	Paging + 정렬 인덱스(LIMIT 50)	17 ms / 621 ms	50
8	2024~2025 (높음)	비효율적 단일 인덱스(order_date만)	96,518 ms	99,985

* 측정 값은 실험 환경/캐시 상태에 따라 달라질 수 있습니다.

선택도별 빠른 비교

2024~2025 (선택도 높음)

Full Scan: 15.18s → Covering Range: 4.35s → Paging(50): 0.621s → 단일 인덱스 오남용: 96.52s

2019~2025 (선택도 낮음)

Full Scan: 8.83s → Covering Range: 0.59s → IN/EXISTS: ~0.2s → Paging(50): 0.017s

쿼리 개요

01_worst_case_no_pk.sql
조인 대상 테이블에 PK/인덱스가 전혀 없을 때의 극단적 비용 확인.

02~05
같은 쿼리 구조라도 **데이터 분포(기간 선택도)**와 **스캔 방식(풀스캔 vs 범위스캔)**에 따라 비용이 크게 달라짐을 확인.

06_rewrite_in_exists_2019_2025.sql
동일 결과 집합을 IN/EXISTS로 재작성하여 중복 제거 비용을 낮춤.

07/07b_paging_semijoin_*.sql
정렬 인덱스 + LIMIT로 실사용 패턴(최신순/페이지 단위)에 맞춘 접근 순서 재설계. 상위 페이지만 읽고 조기 종료.

08_bad_single_col_index_2024_2025.sql
조건 컬럼 단일 인덱스만 두었을 때 조인 키 미선별로 테이블 접근이 폭증하는 안티 패턴.

재현 팁

인덱스 생성/삭제 및 데이터 분포 변경은 각 쿼리 파일에서 명시된 인덱스명을 참고해 동일하게 구성해 주세요.
예) orders_narrow_order_date_member_id_index, orders_2019_2025_order_date_member_id_index, members_last_login_at_index 등

페이지 단위의 실사용 케이스는 07/07b를 참고하시면 됩니다. (정렬 인덱스와 LIMIT 0, 50)

라이선스

리포지토리 정책에 맞게 설정해 주세요. (예: MIT)

문의

이슈/PR로 제안 환영합니다.
실험·수치·환경 차이에 따른 편차가 있을 수 있으니, 테스트 환경을 함께 공유해 주시면 논의에 도움이 됩니다.